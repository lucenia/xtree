/*
 * SPDX-License-Identifier: SSPL-1.0
 *
 * The Lucenia project is source-available software: you can
 * redistribute it and/or modify it under the terms of the
 * Server Side Public License, version 1, as published by
 * MongoDB, Inc.
 *
 * As per the terms of the Server Side Public License, if you
 * make the functionality of this program or a modified version
 * available over a network, you must make the source code
 * available for download.
 *
 * The full text of the Server Side Public License, version 1,
 * can be found at:
 * https://www.mongodb.com/licensing/server-side-public-license
 */

def nativeBuildDir = "${rootProject.projectDir}/build/native"

task configureNative(type: Exec) {
    group = "native"
    description = "Run cmake to configure the native C++ XTree build"

    doFirst {
        file(nativeBuildDir).mkdirs()
    }

    workingDir nativeBuildDir
    def cmakeArgs = [
        'cmake',
        "${project.projectDir}",
        "-DCMAKE_BUILD_TYPE=Release"
    ]

    if (project.hasProperty("versionSuffixOverride")) {
        cmakeArgs += "-DVERSION_SUFFIX_OVERRIDE=${project.versionSuffixOverride}"
    } else if (rootProject.hasProperty("versionSuffixOverride")) {
        cmakeArgs += "-DVERSION_SUFFIX_OVERRIDE=${rootProject.versionSuffixOverride}"
    }

    commandLine cmakeArgs
}

task compileNative(type: Exec) {
    group = "native"
    description = "Compile the native XTree shared library"
    dependsOn configureNative
    workingDir nativeBuildDir
    commandLine 'cmake', '--build', '.'
}

task buildNative(dependsOn: compileNative) {
    group = "build"
    description = "Build (configure + compile) native C++ XTree"
}

task cleanNative(type: Delete) {
    group = "native"
    description = "Clean the native CMake build directory"
    delete file("${rootProject.projectDir}/build/native")
}

task buildNativeAll {
    group = "native"
    description = "Full build: clean, configure, and compile"
    dependsOn cleanNative, buildNative
}

task configureNativeSnapshot(type: Exec) {
    group = "native"
    description = "Configure native build with SNAPSHOT version"
    
    doFirst {
        file(nativeBuildDir).mkdirs()
    }
    
    workingDir nativeBuildDir
    commandLine 'cmake', project.projectDir, "-DCMAKE_BUILD_TYPE=Release", "-DVERSION_SUFFIX_OVERRIDE=-SNAPSHOT"
}

task buildSnapshot {
    group = "build"
    description = "Build a SNAPSHOT version of the native library"
    dependsOn cleanNative, configureNativeSnapshot, compileNative
    compileNative.mustRunAfter configureNativeSnapshot
    configureNativeSnapshot.mustRunAfter cleanNative
}

task testNative {
    group = "verification"
    description = "Run native C++ tests"
    dependsOn compileNative
    
    doLast {
        // Platform-specific test executable path
        def testExecutable = "${nativeBuildDir}/bin/xtree_tests"
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            testExecutable = "${nativeBuildDir}/bin/Release/xtree_tests.exe"
        }
        
        if (!file(testExecutable).exists()) {
            throw new GradleException("Test executable not found: ${testExecutable}")
        }
        
        // Run tests and capture output
        def outputStream = new ByteArrayOutputStream()
        def errorStream = new ByteArrayOutputStream()
        
        def result = exec {
            workingDir nativeBuildDir
            commandLine testExecutable
            standardOutput = outputStream
            errorOutput = errorStream
            ignoreExitValue = true
        }
        
        def output = outputStream.toString()
        def error = errorStream.toString()
        
        // Print the output
        println output
        if (error) {
            println "STDERR: ${error}"
        }
        
        // Check if tests passed regardless of exit code
        if (output.contains("FAILED") || !output.contains("PASSED")) {
            throw new GradleException("Tests failed - check output above for details")
        }
        
        // Extract test summary for reporting
        def matcher = output =~ /\[\s*PASSED\s*\]\s*(\d+)\s*tests?/
        if (matcher) {
            println "âœ“ All ${matcher[0][1]} tests passed successfully"
        }
    }
}

// Wire into standard lifecycle tasks
afterEvaluate {
    tasks.build.dependsOn buildNative
    tasks.clean.dependsOn cleanNative
    tasks.check.dependsOn testNative
    
    // Configure test task to run tests
    task test {
        dependsOn testNative
    }
}

