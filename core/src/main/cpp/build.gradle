/*
 * SPDX-License-Identifier: AGPL-3.0-or-later
 *
 * The Lucenia project is free software: you can redistribute it
 * and/or modify it under the terms of the GNU Affero General
 * Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with this program. If not, see:
 * https://www.gnu.org/licenses/agpl-3.0.html
 */

import java.time.Duration

def nativeBuildDir = "${rootProject.projectDir}/build/native"

// Helper function to detect system page size
def detectSystemPageSize() {
    try {
        def os = System.getProperty("os.name").toLowerCase()
        def arch = System.getProperty("os.arch").toLowerCase()
        
        // Debug logging
        println "Detecting page size for OS: ${os}, Architecture: ${arch}"
        
        if (os.contains("win")) {
            // Windows typically uses 4KB
            return 4096
        } else if (os.contains("mac")) {
            // Check actual CPU architecture using uname
            try {
                def unameProcess = "uname -m".execute()
                unameProcess.waitFor()
                if (unameProcess.exitValue() == 0) {
                    def cpuArch = unameProcess.text.trim()
                    println "CPU architecture (uname -m): ${cpuArch}"
                    if (cpuArch == "arm64") {
                        println "Detected Apple Silicon (native ARM64), using 16KB pages"
                        return 16384
                    }
                }
            } catch (Exception e) {
                println "uname check failed: ${e.message}"
            }
            
            // For macOS, also try getconf to get actual page size
            try {
                def process = "getconf PAGESIZE".execute()
                process.waitFor()
                if (process.exitValue() == 0) {
                    def actualPageSize = process.text.trim().toInteger()
                    println "getconf PAGESIZE returned: ${actualPageSize}"
                    return actualPageSize
                }
            } catch (Exception e) {
                println "getconf failed: ${e.message}"
            }
            
            // Fallback to architecture-based detection
            if (arch.contains("aarch64") || arch.contains("arm") || arch.contains("arm64")) {
                // Apple Silicon uses 16KB pages
                println "Detected Apple Silicon, using 16KB pages"
                return 16384
            } else {
                // Intel Macs use 4KB
                println "Detected Intel Mac, using 4KB pages"
                return 4096
            }
        } else {
            // Linux/Unix - try to get page size
            def process = "getconf PAGESIZE".execute()
            process.waitFor()
            if (process.exitValue() == 0) {
                return process.text.trim().toInteger()
            }
        }
    } catch (Exception e) {
        logger.debug("Could not detect page size: ${e.message}")
    }
    return 0 // Let C++ code use its defaults
}

task configureNative(type: Exec) {
    group = "native"
    description = "Run cmake to configure the native C++ XTree build"

    doFirst {
        file(nativeBuildDir).mkdirs()
        
        // Log detected page size
        def pageSize = detectSystemPageSize()
        if (pageSize > 0) {
            println "Detected system page size: ${pageSize} bytes"
        }
    }

    workingDir nativeBuildDir
    // Allow debug builds with -Pdebug or -PbuildType=Debug
    def buildType = "Release"
    if (project.hasProperty('debug')) {
        buildType = "Debug"
    } else if (project.hasProperty('buildType')) {
        buildType = project.property('buildType')
    }

    def cmakeArgs = [
        'cmake',
        "${project.projectDir}",
        "-DCMAKE_BUILD_TYPE=${buildType}"
    ]

    println "Configuring native build with CMAKE_BUILD_TYPE=${buildType}"
    
    // Add detected page size if available
    def detectedPageSize = detectSystemPageSize()
    if (detectedPageSize > 0) {
        cmakeArgs += "-DXTREE_PAGE_SIZE=${detectedPageSize}"
    }

    // Add sanitizer flags
    if (project.hasProperty("asan")) {
        cmakeArgs += "-DENABLE_ASAN=ON"
    }
    if (project.hasProperty("ubsan")) {
        cmakeArgs += "-DENABLE_UBSAN=ON"
    }
    if (project.hasProperty("tsan")) {
        cmakeArgs += "-DENABLE_TSAN=ON"
    }

    // Add CMAKE_TOOLCHAIN_FILE if specified (for Windows vcpkg support)
    if (System.getenv("CMAKE_TOOLCHAIN_FILE")) {
        cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=${System.getenv("CMAKE_TOOLCHAIN_FILE")}"
    }
    
    // Add CMAKE_GENERATOR if specified (for Windows MinGW support)
    if (System.getenv("CMAKE_GENERATOR")) {
        cmakeArgs += "-G${System.getenv("CMAKE_GENERATOR")}"
    }
    
    // Add VCPKG_TARGET_TRIPLET if specified (for Windows vcpkg support)
    if (System.getenv("VCPKG_TARGET_TRIPLET")) {
        cmakeArgs += "-DVCPKG_TARGET_TRIPLET=${System.getenv("VCPKG_TARGET_TRIPLET")}"
    }

    if (project.hasProperty("versionSuffixOverride")) {
        cmakeArgs += "-DVERSION_SUFFIX_OVERRIDE=${project.versionSuffixOverride}"
    } else if (rootProject.hasProperty("versionSuffixOverride")) {
        cmakeArgs += "-DVERSION_SUFFIX_OVERRIDE=${rootProject.versionSuffixOverride}"
    }

    commandLine cmakeArgs
}

task compileNative(type: Exec) {
    group = "native"
    description = "Compile the native XTree shared library"
    dependsOn configureNative
    workingDir nativeBuildDir
    
    // Enable parallel build using all available CPU cores
    def parallelJobs = Runtime.runtime.availableProcessors()
    commandLine 'cmake', '--build', '.', '--parallel', parallelJobs.toString()
    
    doFirst {
        println "Building with ${parallelJobs} parallel jobs"
    }
}

task buildNative(dependsOn: compileNative) {
    group = "build"
    description = "Build (configure + compile) native C++ XTree"
}

task cleanNative(type: Delete) {
    group = "native"
    description = "Clean the native CMake build directory"
    delete file("${rootProject.projectDir}/build/native")
}

task buildNativeAll {
    group = "native"
    description = "Full build: clean, configure, and compile"
    dependsOn cleanNative, buildNative
}

task configureNativeSnapshot(type: Exec) {
    group = "native"
    description = "Configure native build with SNAPSHOT version"
    
    doFirst {
        file(nativeBuildDir).mkdirs()
        
        // Log detected page size
        def pageSize = detectSystemPageSize()
        if (pageSize > 0) {
            println "Detected system page size: ${pageSize} bytes"
        }
    }
    
    workingDir nativeBuildDir
    // Allow debug builds with -Pdebug or -PbuildType=Debug
    def buildType = "Release"
    if (project.hasProperty('debug')) {
        buildType = "Debug"
    } else if (project.hasProperty('buildType')) {
        buildType = project.property('buildType')
    }

    def cmakeArgs = [
        'cmake',
        project.projectDir,
        "-DCMAKE_BUILD_TYPE=${buildType}",
        "-DVERSION_SUFFIX_OVERRIDE=-SNAPSHOT"
    ]

    println "Configuring native SNAPSHOT build with CMAKE_BUILD_TYPE=${buildType}"
    
    // Add detected page size if available
    def detectedPageSize = detectSystemPageSize()
    if (detectedPageSize > 0) {
        cmakeArgs += "-DXTREE_PAGE_SIZE=${detectedPageSize}"
    }
    
    // Add CMAKE_TOOLCHAIN_FILE if specified (for Windows vcpkg support)
    if (System.getenv("CMAKE_TOOLCHAIN_FILE")) {
        cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=${System.getenv("CMAKE_TOOLCHAIN_FILE")}"
    }
    
    // Add CMAKE_GENERATOR if specified (for Windows MinGW support)
    if (System.getenv("CMAKE_GENERATOR")) {
        cmakeArgs += "-G${System.getenv("CMAKE_GENERATOR")}"
    }
    
    // Add VCPKG_TARGET_TRIPLET if specified (for Windows vcpkg support)
    if (System.getenv("VCPKG_TARGET_TRIPLET")) {
        cmakeArgs += "-DVCPKG_TARGET_TRIPLET=${System.getenv("VCPKG_TARGET_TRIPLET")}"
    }
    
    commandLine cmakeArgs
}

task buildSnapshot {
    group = "build"
    description = "Build a SNAPSHOT version of the native library"
    dependsOn cleanNative, configureNativeSnapshot, compileNative
    compileNative.mustRunAfter configureNativeSnapshot
    configureNativeSnapshot.mustRunAfter cleanNative
}

task testNative {
    group = "verification"
    description = "Run native C++ tests"
    dependsOn compileNative
    
    doLast {
        // Platform-specific test executable path
        def testExecutable = "${nativeBuildDir}/bin/xtree_tests"
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            // Check both possible locations on Windows
            def releaseExe = "${nativeBuildDir}/bin/Release/xtree_tests.exe"
            def directExe = "${nativeBuildDir}/bin/xtree_tests.exe"
            
            if (file(releaseExe).exists()) {
                testExecutable = releaseExe
            } else if (file(directExe).exists()) {
                testExecutable = directExe
            } else {
                throw new GradleException("Test executable not found at ${releaseExe} or ${directExe}")
            }
        }
        
        if (!file(testExecutable).exists()) {
            throw new GradleException("Test executable not found: ${testExecutable}")
        }
        
        println "Running XTree native tests..."
        println "=" * 60
        
        // Run tests with real-time output processing
        def testCount = 0
        def passedCount = 0
        def failedCount = 0
        def currentSuite = ""
        def testsFailed = false
        
        // Set up environment with Boost DLL path for Windows
        def procBuilder = new ProcessBuilder(testExecutable)
            .directory(file(nativeBuildDir))
            .redirectErrorStream(true)
            
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            def env = procBuilder.environment()
            def currentPath = env.get("PATH") ?: ""
            
            // Add common Boost DLL locations to PATH
            def boostPaths = [
                "C:\\local\\boost_1_88_0\\stage\\lib",
                "C:\\boost\\stage\\lib",
                "C:\\boost_1_88_0\\stage\\lib"
            ]
            
            // Check BOOST_ROOT environment variable
            def boostRoot = env.get("BOOST_ROOT")
            if (boostRoot) {
                boostPaths.add(0, "${boostRoot}\\stage\\lib".toString())
            }
            
            // Add existing Boost paths that actually exist
            def existingBoostPaths = boostPaths.findAll { path ->
                file(path).exists()
            }
            
            if (existingBoostPaths) {
                def newPath = existingBoostPaths.join(";") + ";" + currentPath
                env.put("PATH", newPath)
                println "Added Boost DLL paths to runtime PATH: ${existingBoostPaths.join(', ')}"
            } else {
                println "Warning: No Boost DLL directories found in standard locations"
                println "Searched: ${boostPaths.join(', ')}"
            }
        }
        
        def proc = procBuilder.start()
        
        // Simply run the tests and capture all output
        def output = new StringBuilder()
        def error = new StringBuilder()
        
        proc.consumeProcessOutput(output, error)
        def exitCode = proc.waitFor()
        
        // Process the complete output
        output.toString().eachLine { line ->
            // Detect test suite starts
            if (line =~ /\[----------\]\s+\d+\s+tests?\s+from\s+(\w+)/) {
                def matcher = line =~ /\[----------\]\s+\d+\s+tests?\s+from\s+(\w+)/
                currentSuite = matcher[0][1]
                println "\n${line}"
            }
            // Detect individual test starts
            else if (line =~ /\[\s*RUN\s*\]/) {
                testCount++
                print "[${testCount}] ${line}"
            }
            // Detect test passes
            else if (line =~ /\[\s*OK\s*\]/) {
                passedCount++
                println " ✓"
            }
            // Detect test failures
            else if (line =~ /\[\s*FAILED\s*\]/) {
                failedCount++
                testsFailed = true
                println " ✗"
                println line
            }
            // Show test summary lines
            else if (line =~ /\[==========\]/ || line =~ /\[\s*PASSED\s*\]/) {
                println "${line}"
            }
            // Show performance metrics
            else if (line.contains("operations:") || line.contains("queries:") || 
                     line.contains("insertion:") || line.contains("Average results")) {
                println "  ${line}"
            }
        }
        
        if (error.toString()) {
            println "Errors: ${error}"
        }
        
        println "=" * 60
        
        if (exitCode != 0 || testsFailed) {
            throw new GradleException("Tests failed: ${failedCount} failed, ${passedCount} passed")
        }
        
        // testCount may be incorrect due to disabled tests, so just report passed count
        println "✓ All ${passedCount} tests passed successfully!"
    }
}

// Add benchmarks task
task benchmarksNative(type: Exec) {
    dependsOn buildNative
    
    description = 'Run native C++ benchmarks'
    
    def benchmarksExe = file("${nativeBuildDir}/bin/xtree_benchmarks")
    
    doFirst {
        if (!benchmarksExe.exists()) {
            throw new GradleException("Benchmarks executable not found at ${benchmarksExe}")
        }
        
        println "=" * 60
        println "Running XTree native benchmarks..."
        println "=" * 60
        println "Note: Benchmarks may take up to 30 minutes to complete"
        println "=" * 60
    }
    
    // Allow passing arguments to benchmarks with -PbenchmarkArgs="..."
    def benchmarkArgs = project.hasProperty('benchmarkArgs') ? 
        project.property('benchmarkArgs').split(' ') : []
    
    commandLine([benchmarksExe.absolutePath] + benchmarkArgs)
    workingDir nativeBuildDir
    
    // Increase timeout for benchmarks (30 minutes)
    // Can be overridden with -Pbenchmark.timeout=60 (in minutes)
    def timeoutMinutes = project.hasProperty('benchmark.timeout') ? 
        project.property('benchmark.timeout') as int : 30
    timeout = Duration.ofMinutes(timeoutMinutes)
    
    // Ignore exit code 13 (SIGPIPE) which can happen when output pipe is closed
    ignoreExitValue = true
    
    doLast {
        // Check if benchmarks actually failed (non-zero exit code other than 13)
        def result = executionResult.get()
        if (result.exitValue != 0 && result.exitValue != 13) {
            throw new GradleException("Benchmarks failed with exit code: ${result.exitValue}")
        }
        println "=" * 60
        println "✓ Benchmarks completed successfully!"
    }
}

// Wire into standard lifecycle tasks
afterEvaluate {
    tasks.build.dependsOn buildNative
    tasks.clean.dependsOn cleanNative
    
    // Configure test task to run tests
    task test {
        dependsOn testNative
    }
    
    // Configure benchmarks task
    task benchmarks {
        dependsOn benchmarksNative
    }
}

