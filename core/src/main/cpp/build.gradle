/*
 * SPDX-License-Identifier: SSPL-1.0
 *
 * The Lucenia project is source-available software: you can
 * redistribute it and/or modify it under the terms of the
 * Server Side Public License, version 1, as published by
 * MongoDB, Inc.
 *
 * As per the terms of the Server Side Public License, if you
 * make the functionality of this program or a modified version
 * available over a network, you must make the source code
 * available for download.
 *
 * The full text of the Server Side Public License, version 1,
 * can be found at:
 * https://www.mongodb.com/licensing/server-side-public-license
 */

def nativeBuildDir = "${rootProject.projectDir}/build/native"

// Helper function to detect system page size
def detectSystemPageSize() {
    try {
        def os = System.getProperty("os.name").toLowerCase()
        def arch = System.getProperty("os.arch").toLowerCase()
        
        if (os.contains("win")) {
            // Windows typically uses 4KB
            return 4096
        } else if (os.contains("mac")) {
            if (arch.contains("aarch64") || arch.contains("arm")) {
                // Apple Silicon uses 16KB pages
                return 16384
            } else {
                // Intel Macs use 4KB
                return 4096
            }
        } else {
            // Linux/Unix - try to get page size
            def process = "getconf PAGESIZE".execute()
            process.waitFor()
            if (process.exitValue() == 0) {
                return process.text.trim().toInteger()
            }
        }
    } catch (Exception e) {
        logger.debug("Could not detect page size: ${e.message}")
    }
    return 0 // Let C++ code use its defaults
}

task configureNative(type: Exec) {
    group = "native"
    description = "Run cmake to configure the native C++ XTree build"

    doFirst {
        file(nativeBuildDir).mkdirs()
        
        // Log detected page size
        def pageSize = detectSystemPageSize()
        if (pageSize > 0) {
            println "Detected system page size: ${pageSize} bytes"
        }
    }

    workingDir nativeBuildDir
    def cmakeArgs = [
        'cmake',
        "${project.projectDir}",
        "-DCMAKE_BUILD_TYPE=Release"
    ]
    
    // Add detected page size if available
    def detectedPageSize = detectSystemPageSize()
    if (detectedPageSize > 0) {
        cmakeArgs += "-DXTREE_PAGE_SIZE=${detectedPageSize}"
    }

    // Add CMAKE_TOOLCHAIN_FILE if specified (for Windows vcpkg support)
    if (System.getenv("CMAKE_TOOLCHAIN_FILE")) {
        cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=${System.getenv("CMAKE_TOOLCHAIN_FILE")}"
    }
    
    // Add CMAKE_GENERATOR if specified (for Windows MinGW support)
    if (System.getenv("CMAKE_GENERATOR")) {
        cmakeArgs += "-G${System.getenv("CMAKE_GENERATOR")}"
    }
    
    // Add VCPKG_TARGET_TRIPLET if specified (for Windows vcpkg support)
    if (System.getenv("VCPKG_TARGET_TRIPLET")) {
        cmakeArgs += "-DVCPKG_TARGET_TRIPLET=${System.getenv("VCPKG_TARGET_TRIPLET")}"
    }

    if (project.hasProperty("versionSuffixOverride")) {
        cmakeArgs += "-DVERSION_SUFFIX_OVERRIDE=${project.versionSuffixOverride}"
    } else if (rootProject.hasProperty("versionSuffixOverride")) {
        cmakeArgs += "-DVERSION_SUFFIX_OVERRIDE=${rootProject.versionSuffixOverride}"
    }

    commandLine cmakeArgs
}

task compileNative(type: Exec) {
    group = "native"
    description = "Compile the native XTree shared library"
    dependsOn configureNative
    workingDir nativeBuildDir
    commandLine 'cmake', '--build', '.'
}

task buildNative(dependsOn: compileNative) {
    group = "build"
    description = "Build (configure + compile) native C++ XTree"
}

task cleanNative(type: Delete) {
    group = "native"
    description = "Clean the native CMake build directory"
    delete file("${rootProject.projectDir}/build/native")
}

task buildNativeAll {
    group = "native"
    description = "Full build: clean, configure, and compile"
    dependsOn cleanNative, buildNative
}

task configureNativeSnapshot(type: Exec) {
    group = "native"
    description = "Configure native build with SNAPSHOT version"
    
    doFirst {
        file(nativeBuildDir).mkdirs()
        
        // Log detected page size
        def pageSize = detectSystemPageSize()
        if (pageSize > 0) {
            println "Detected system page size: ${pageSize} bytes"
        }
    }
    
    workingDir nativeBuildDir
    def cmakeArgs = [
        'cmake', 
        project.projectDir, 
        "-DCMAKE_BUILD_TYPE=Release", 
        "-DVERSION_SUFFIX_OVERRIDE=-SNAPSHOT"
    ]
    
    // Add detected page size if available
    def detectedPageSize = detectSystemPageSize()
    if (detectedPageSize > 0) {
        cmakeArgs += "-DXTREE_PAGE_SIZE=${detectedPageSize}"
    }
    
    // Add CMAKE_TOOLCHAIN_FILE if specified (for Windows vcpkg support)
    if (System.getenv("CMAKE_TOOLCHAIN_FILE")) {
        cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=${System.getenv("CMAKE_TOOLCHAIN_FILE")}"
    }
    
    // Add CMAKE_GENERATOR if specified (for Windows MinGW support)
    if (System.getenv("CMAKE_GENERATOR")) {
        cmakeArgs += "-G${System.getenv("CMAKE_GENERATOR")}"
    }
    
    // Add VCPKG_TARGET_TRIPLET if specified (for Windows vcpkg support)
    if (System.getenv("VCPKG_TARGET_TRIPLET")) {
        cmakeArgs += "-DVCPKG_TARGET_TRIPLET=${System.getenv("VCPKG_TARGET_TRIPLET")}"
    }
    
    commandLine cmakeArgs
}

task buildSnapshot {
    group = "build"
    description = "Build a SNAPSHOT version of the native library"
    dependsOn cleanNative, configureNativeSnapshot, compileNative
    compileNative.mustRunAfter configureNativeSnapshot
    configureNativeSnapshot.mustRunAfter cleanNative
}

task testNative {
    group = "verification"
    description = "Run native C++ tests"
    dependsOn compileNative
    
    doLast {
        // Platform-specific test executable path
        def testExecutable = "${nativeBuildDir}/bin/xtree_tests"
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            testExecutable = "${nativeBuildDir}/bin/Release/xtree_tests.exe"
        }
        
        if (!file(testExecutable).exists()) {
            throw new GradleException("Test executable not found: ${testExecutable}")
        }
        
        println "Running XTree native tests..."
        println "=" * 60
        
        // Run tests with real-time output processing
        def testCount = 0
        def passedCount = 0
        def failedCount = 0
        def currentSuite = ""
        def testsFailed = false
        
        def proc = new ProcessBuilder(testExecutable)
            .directory(file(nativeBuildDir))
            .redirectErrorStream(true)
            .start()
        
        // Simply run the tests and capture all output
        def output = new StringBuilder()
        def error = new StringBuilder()
        
        proc.consumeProcessOutput(output, error)
        def exitCode = proc.waitFor()
        
        // Process the complete output
        output.toString().eachLine { line ->
            // Detect test suite starts
            if (line =~ /\[----------\]\s+\d+\s+tests?\s+from\s+(\w+)/) {
                def matcher = line =~ /\[----------\]\s+\d+\s+tests?\s+from\s+(\w+)/
                currentSuite = matcher[0][1]
                println "\n${line}"
            }
            // Detect individual test starts
            else if (line =~ /\[\s*RUN\s*\]/) {
                testCount++
                print "[${testCount}] ${line}"
            }
            // Detect test passes
            else if (line =~ /\[\s*OK\s*\]/) {
                passedCount++
                println " ✓"
            }
            // Detect test failures
            else if (line =~ /\[\s*FAILED\s*\]/) {
                failedCount++
                testsFailed = true
                println " ✗"
                println line
            }
            // Show test summary lines
            else if (line =~ /\[==========\]/ || line =~ /\[\s*PASSED\s*\]/) {
                println "${line}"
            }
            // Show performance metrics
            else if (line.contains("operations:") || line.contains("queries:") || 
                     line.contains("insertion:") || line.contains("Average results")) {
                println "  ${line}"
            }
        }
        
        if (error.toString()) {
            println "Errors: ${error}"
        }
        
        println "=" * 60
        
        if (exitCode != 0 || testsFailed) {
            throw new GradleException("Tests failed: ${failedCount} failed, ${passedCount} passed out of ${testCount} total")
        }
        
        println "✓ All ${passedCount} tests passed successfully!"
    }
}

// Wire into standard lifecycle tasks
afterEvaluate {
    tasks.build.dependsOn buildNative
    tasks.clean.dependsOn cleanNative
    
    // Configure test task to run tests
    task test {
        dependsOn testNative
    }
}

